---
title: 撰寫良好程式碼的原則
description: 探討撰寫良好程式碼的必要性，以及一般撰寫良好程式碼的主要原則。
categories: [Programming]
tags: [Coding, PS/CP]
image: /assets/img/technology.jpg
---
## 撰寫良好程式碼的必要性
如果只急於快速編寫程式碼來實現當前的功能，[技術債務](/posts/Technical-debt/)可能會增加到無法控制的程度，導致後續維護出現問題。因此，在進行開發專案時，從一開始就盡可能撰寫可讀性高且易於維護的良好程式碼，其重要性不言而喻。

對於演算法問題解決（PS, Problem Solving）或競賽程式設計（CP, Competitive Programming）來說，通常在問題解決或比賽結束後不會再使用這些程式碼，特別是在CP中由於有時間限制，有人認為快速實現比撰寫良好程式碼更重要。要回答這個問題，需要思考自己為什麼要進行PS/CP以及追求什麼方向。

個人認為，通過PS/CP可以學到以下幾點：
- 在給定的執行時間和記憶體限制等條件下解決問題的過程中，可以使用並熟悉各種演算法和資料結構，從而在實際專案中也能夠對特定情況下應該使用哪種演算法和資料結構有所感覺
- 編寫並提交程式碼後，可以立即獲得關於正確/錯誤、執行時間和記憶體使用量的客觀反饋，因此可以練習快速且熟練地編寫準確無誤的程式碼
- 可以通過查看其他高手編寫的程式碼，與自己的程式碼進行比較，找出需要改進的地方
- 相比實際開發專案，PS/CP涉及反覆編寫規模較小且功能相似的程式碼，因此（特別是獨自練習PS時）可以不受截止日期等限制，專注於細節，練習編寫簡潔優良的程式碼

雖然有些人可能純粹將PS/CP作為興趣，但如果是為了間接提高程式設計能力而進行PS/CP，那麼「練習撰寫良好程式碼」這一點與前三點同樣重要。因為撰寫良好程式碼並非與生俱來的能力，而是需要通過反覆練習才能逐漸熟練。此外，複雜且難以閱讀的程式碼不僅難以除錯，連自己也難以一次準確編寫，因此花時間在低效率的除錯上，反而可能無法快速實現。雖然PS/CP與實際工作有很大差異，但基於上述原因，完全不關注良好程式碼的撰寫而只急於當前實現是本末倒置的，因此我個人認為在PS/CP中也應該編寫簡潔高效的程式碼。

> 12024.12 補充評論：  
> 從目前的趨勢來看，除非你是主修電腦科學並以開發為職業，否則如果只是將程式設計作為數值分析或實驗數據分析等工具，那麼積極利用GitHub Copilot、Cursor、Windsurf等AI工具來節省時間，並將節省下來的時間用於學習其他內容可能更好。如果純粹將PS/CP作為興趣，當然沒人會阻止，但為了練習程式碼編寫而投入時間和精力在PS/CP上，現在看來成本效益比已經相當低。甚至對於開發職位來說，至少作為入職考試的程式設計測驗，其重要性可能會比以前降低不少。
{: .prompt-warning }

## 撰寫良好程式碼的原則
無論是在比賽中編寫的程式碼還是在實務中編寫的程式碼，良好程式碼的條件大致相同。本文將介紹一般撰寫良好程式碼的主要原則。不過，在PS/CP中為了快速實現，相較於實務可能會有一些妥協的部分，這些情況會在文中特別提及。

### 編寫簡潔的程式碼
> "KISS(Keep It Simple, Stupid)"

- 程式碼越短越簡潔，自然減少打字錯誤或簡單錯誤的可能性，也更容易除錯
- 盡可能編寫不需額外註解就能輕鬆理解的程式碼，只在真正需要時添加註解提供詳細說明。比起依賴註解，保持程式碼結構本身的簡潔更為理想
- 撰寫註解時，應清晰簡潔
- 傳遞給一個函數的參數應控制在3個以內，如果需要傳遞更多參數，應將它們封裝成一個物件
- 條件式的深度（depth）如果變成雙重、三重會降低可讀性，因此應盡量避免增加條件式的深度
  例如：相比上面的程式碼，使用保護條款（Guard Clause）的下面程式碼在可讀性方面更有優勢

  ```python
  async def verify_token(email: str, token: str, purpose: str):
      user = await user_service.get_user_by_email(email)
  
      if user:
          token = await user_service.get_token(user)
  
          if token :
              if token.purpose == 'reset':
                  return True
      return False
  ```
  ```python
  async def verify_token(email: str, token: str, purpose: str):
      user = await user_service.get_user_by_email(email)
  
      if not user:
          return False
    
      token = await user_service.get_token(user)
  
      if not token or token.purpose != 'reset':
          return False
    
    return True
  ```
- 不過，在PS/CP中，為了進一步縮短程式碼長度以快速編寫，有時會使用C/C++的巨集（macro）這種技巧。這在時間緊迫的比賽中偶爾使用很有用，但這只適用於PS/CP，一般而言應避免在C++中使用巨集。
  例如：

  ```c++
  #define FOR(i,n) for(int i=0; i<n; i++)
  ```

### 程式碼模組化
> "DRY(Don't Repeat Yourself)"

- 當重複使用相同程式碼時，應將該部分分離為函數或類別以便重複使用
- 通過模組化積極重複使用程式碼可以提高可讀性，且當需要修改程式碼時，只需修改該函數或類別一次，使維護更容易
- 原則上，一個函數最好只執行一項功能而不是多項功能。不過，在PS/CP中編寫的程式碼通常是執行簡單功能的小規模程式，因此重複使用有限，且由於時間限制，可能難以像實務中那樣嚴格遵循原則。

### 利用標準函式庫
> "Don't reinvent the wheel"

- 在學習演算法或資料結構的階段，直接實現佇列或堆疊等資料結構、排序演算法等來理解原理很有用，但除此之外，應積極利用標準函式庫
- 標準函式庫已經被無數次使用和驗證，且優化良好，比自己重新實現更有效率
- 使用現有的函式庫可以避免不必要地浪費時間直接實現相同功能的程式碼，且在協作時，其他團隊成員也更容易理解你編寫的程式碼

### 使用一致且明確的命名法
> "Follow standard conventions"

- 使用不含糊的變數名和函數名
- 通常每種程式設計語言都有相應的命名慣例（naming convention），應學習並在宣告類別、函數、變數等時一致地應用所使用語言標準函式庫中的命名慣例
- 命名時應清楚表明每個變數、函數、類別的功能，以及布林（boolean）類型在什麼條件下會返回真（True）

### 所有資料都應規範化儲存
- 所有資料都應以一種一致的格式規範化處理
- 如果同一資料有兩種以上的格式，可能會導致字串表示略有不同，或雜湊值不同等難以發現的微妙錯誤
- 儲存和處理時區、字串等資料時，應在接收或計算後立即轉換為UTC、UTF-8編碼等單一標準格式。最好在表示該資料的類別的建構函數中從一開始就執行規範化，或在接收資料的函數中立即執行規範化。

### 分離程式碼的邏輯和資料
- 與程式碼邏輯無關的資料不應直接放在條件式中，而應分離為獨立的表格
  例如：比起上面的程式碼，下面的程式碼寫法更為理想。

  ```c++
  string getMonthName(int month){
    if(month == 1) return "January";
    if(month == 2) return "February";
    ...
    if(month == 12) return "December";
  }
  ```
  ```c++
  const string monthName[] = {"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"};

  string getMonthName(int month){
    return monthName[month-1];
  }
  ```
